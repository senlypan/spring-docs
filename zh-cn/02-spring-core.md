# Spring核心

> 作者: 潘深练
>
> 更新: 2022-03-14


## 关于框架

对于程序员来说，我们通常知道很多概念，例如组件、模块、系统、框架、架构等。

- **组件**

- **模块**

- **框架**，本质上是一些实用经验集合。即是前辈们在实际开发过程中积攒下来的实战经验，累积成一套实用工具，避免你在开发过程中重复去造轮子，特别是帮你把日常中能遇到的场景或问题都给屏蔽掉，框架的意义在于屏蔽掉开发的基础复杂度、屏蔽掉此类共性的东西，让框架使用者只关注于差异面，即业务层面的实现。简而言之，框架只干一件事，那就是 **简化开发**。然后在此基础上，可能会再考虑一些安全性、效率、性能、弹性、管理、拓展、解耦等等。

- **系统**

- **架构**，是我们关注的系统层面的一个顶层结构。

## Spring核心

Spring 作为一个框架，目的也是：**简化开发** ，只不过在简化开发的过程中 Spring 做了一个特别的设计，那就是 `Bean管理`，这也是 Spring 的设计核心，而 Bean 生命周期管理的设计巧妙的 `解耦了 Bean 之间的关系`。

因此 Spring 核心特性就是 **解耦** 和 **简化**。

![02-spring-001](../_media/image/02-spring/02-spring-001.png)

Spring 框架图示展示得很清晰，基本描绘出 Spring 框架的核心：

- **内核**
- **外延**

简单说，就是 Spring 设计了一个核心容器 `Core Container`，这里头主要就是管理 Bean 生命周期，然后为了服务这些业务 Bean ，引入了 `Core` , `Context` , `SpEL` 等工具到核心容器中。然后在核心容器基础上，又为了把更多的能力集成进来，例如为了拓展 **数据访问** 能力加入了 `JDBC` 、`ORM` 、`OXM` 、`JMS` 、`Transactions`等，为了拓展 **Web** 能力加入了 `WebSocket` 、`Servlet`、`Web`、`Portlet`等，其中为了把 `RequestMapping` 或 `Servlet` 等这些使用集成到业务 Bean 上，引入了 `AOP` ，包括还有引入（最终是提供） `Aspects`、`Instrumentation`、`Messageing`等增强方式。

所以仔细一看，Spring 就是把像数据库访问、Web支持、缓存、消息发送等等这些能力集成到业务 Bean 上，并提供一些测试支持。总结来说理解 Spring 就两点：

1. **Bean管理：** 解耦Bean关系。理解为内核，从 Bean 的定义、创建、管理等，这是业务Bean。

2. **功能增强：** 解耦功能、声明式简化。理解为外延，在业务Bean基础上，需要访库等能力，那就是功能增强。


基本体现的就是两个核心特性，一个 **解耦**、一个 **简化**。


Bean管理本身就是在做解耦，解除耦合，这个解耦指 Bean 和 Bean 之间的关联关系，Bean 之间通过接口协议互相串联起来的，至于每个接口有多少个实现类，那都不会有任何影响，Bean 之间只保留单点通道，通过接口相互隔离，关系都交给 Spring 管理，这样就避免了实现类和实现类之间出现一些耦合，就算方法增减了、引用变更了也不至于互相污染。

功能增强本身就是在做简化，例如声明式简化，像声明式编程，使用者只需要告诉框架他要什么，不用管框架是如何实现的。另外简化方面还有 **约定优于配置** （当然这个确切的说是 `SpringBoot` 里的设计），约定优于配置其实就是约定好了无需去做复杂的配置，例如你引入一个什么组件或能力就像 `redis` 或 `kafka` ，你不需要提前配置，因为 `springboot` 已经为你默认配置。

> 最后再总结 Spring 框架特性，就是 **解耦** 和 **简化** ，没有其它了。

对于 SpringBoot，简单理解就是在 Spring 框架基础上添加了一个 `SPI 可拓展机制` 和 `版本管理`，让易用性更高，简化升级。

对于 SpringCloud，简单理解就是，由于 SpringBoot 的 **依赖** 可以被很好的管理，**拓展** 可以被可插拔的拓展，因此在 SpringBoot 基础上集成了很多跟微服务架构相关的能力，例如集成了很多组件。

所以我们说回 Spring 的核心设计。

## IoC 

我们说了 Spring 的其一特性是 **解耦**，那到底是使用什么来解耦？ 

![02-spring-core-001](../_media/image/02-spring-core/02-spring-core-001.png)

控制反转（`Inversion of Control`，缩写为`IoC`），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（`Dependency Injection`，简称`DI`），还有一种方式叫“依赖查找”（`Dependency Lookup`，`EJB`和`Apache Avalon` 都使用这种方式）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。

简单来说，就是原本 Bean 与 Bean 之间的这种互相调用，变成了由 `IoC` 容器去统一调配。如果没使用 `IoC` 容器统一管理业务 Bean，你的应用在部署、修改、迭代的时候，业务 Bean 是会侵入代码实现并互相调用的。

> `IoC` 容器是面向 `迭代` 起作用，如果你的应用就 **不存在迭代** 的情况，即系统是万年不变的，那没必要引入 `IoC`，因为你每引入一项技术，都势必会增加复杂度，所以额外引入 `IoC` 也一样会增加你整体应用的复杂度，所以假如 **不存在迭代**，大可直接写死A类引用B类，B类又写死引用C类，无需引入 `IoC`。一定要理解每一项技术背后是为了解决什么问题，同时在做架构设计的时候记住两个原则：**合适** 、**简单**。当然，实际上我们大部分应用是 **持续迭代** 的，在类实现上、互相引用上、甚至接口协议上都有可能变化，所以一般引入 `IoC` 是合适的（如果是接口协议变化，即参数或返回值发生变化，那还是需要改动类间的代码的）。

具体的，`IoC` 相当于是把 Bean 实例的创建过程交给 Spring 管理，无论是通过 `XML`、`JavaConfig`，还是 `注解` 方式，最终都是把实例化的工作交给 Spring 负责，之后 Bean 之间通过接口相互调用，而实例化过程中就涉及到 `注入`，无论采用什么方式来实例化 Bean，`注入` 的类别就两种：

- **Setter注入** ： 通过 `setter` 来设置，发生在对象 **实例化之后** 设置。
- **构造器注入** ： 通过构造器注入，发生在对象 **实例化之前** 就得把参数/实例准备好。

**setter注入：**

1. 与传统的JavaBean的写法更相似，程序开发人员更容易理解、接受。通过`setter`方法设定依赖关系显得更加直观、自然。
2. 对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。Spring在创建Bean实例时，需要同时实例化其依赖的全部实例，因而导致性能下降。而使用设值注入，则能避免这些问题。
3. 尤其在某些成员变量可选的情况下，多参数的构造器更加笨重。

**构造器注入：**

1. 构造器注入可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入。
2. 对于依赖关系无需变化的Bean，构造注入更有用处。因为没有`setter`方法，所有的依赖关系全部在构造器内设定，无须担心后续的代码对依赖关系产生破坏。
3. 依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系，对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则。

其中，注入方式使用了 `反射`。

## 反射 

![02-spring-core-002](../_media/image/02-spring-core/02-spring-core-002.png)

![02-spring-core-003](../_media/image/02-spring-core/02-spring-core-003.png)

`java.lang.reflect` 包提供了许多反射类，用于获取或设置实例对象。简单来说，反射能够：

1. **在运行时** 判断任意一个对象所属的类；
2. 在运行时构造任意一个类的对象；
3. 在运行时判断任意一个类所具有的成员变量和方法；
4. 在运行时调用任意一个对象的方法；
5. **生成动态代理**。

`IoC`和`反射`，只是把 Bean 的实例创建处理完，而后续还有 **功能增强**，功能增强靠的就是 `AOP`。

## AOP

AOP（`Aspect Oriented Programming`的缩写）就是面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。一般有两类实现方式：

- **命令式编程** ，new一个代理类，在方法前后做一些增强逻辑，此种实现相对复杂，但是灵活性最高。
- **声明式编程+注解** ， spring大部分是此种实现，很大程度上为了简化，实际使用居多。

```java
// 第一次延迟1秒后执行，之后按fixedRate的规则每5秒再执行一次
@Scheduled(InitialDelay=1000, fixedRate=5000) 
```

```java
@Cacheable(name="book",key="#isbn",conditional="xxx",allEntries=true,beforeInvocation=true)
public Book findBook(ISBN isbn,boolean checkWarehouse,boolean includeUsed)
```

```java
// 针对某个方法不开启事务
@Transactional(propagation=Propagation.NOT_SUPPORTED) 
```

> AOP 功能增强

- 性能监控，在方法调用前后记录调用时间，方法执行太长或超时报警。
- 缓存代理，缓存某方法的返回值，下次执行该方法时，直接从缓存里获取。
- 软件破解，使用AOP修改软件的验证类的判断逻辑。
- 记录日志，在方法执行前后记录系统操作日志。
- 工作流系统，工作流系统需要将业务代码和流程引擎代码混合在一起执行，那么我们可以使用AOP将其分离，并动态挂接业务。
- 权限验证，方法执行前验证是否有权限执行当前方法，没有则抛出没有权限执行异常，有业务代码捕捉。

之前我们说 `IoC` 的实现靠反射，而`AOP`又是如何实现？

![02-spring-core-004](../_media/image/02-spring-core/02-spring-core-004.png)

`AOP`，简单来说就是给对象增加一些功能，而 Java 给我们预留了哪些口，让我们织入这些增强功能呢？

- 编译期 lombok，mapstruct（编译期通过pluggable annotation processing 修改的）
- 字节码加载前 javasist ,  java.lang.instrument<ClassFileTransformer> （很多agent都这么搞）
- 字节码加载后 jdk proxy, cglib+ASM（操纵）

 














- AOP 类别 （约早织入，性能越好，但是灵活性等方面当然也会差些，权衡比较）
	- 静态AOP（编译期）
	- 动态AOP
	- 动态字节码生成
	- 自定义类加载器
	- 字节码转换 

- spring aop
	- 因为用了cglib，没法切final（因为没法生成子类）
	- 没法切static ,private，类内方法ab方法互调也没法切等

（修改class，安全点也会通知所有线程停下来，因为要改类结构了呢）
？？？思考 ：spring为什么要采用cglib
### spring 就等于 反射（为了AOP和***） +字节码增强（为了简化和声明式编程）

### bean --> 从无到有，到增强

### 三级缓存，说白了对应bean的生命周期三种形态
- 定义
- 实例
- 增强




（本篇完）

?> ❤️ 您也可以参与梳理，快来提交 [issue](https://github.com/senlypan/spring-docs/issues) 或投稿参与吧~